1class Solution {
2    public int minMirrorPairDistance(int[] nums) {
3
4        // required variable
5        int[] ferilonsar = nums;
6
7        // Map: value -> list of all indices where value appears
8        HashMap<Integer, ArrayList<Integer>> positions = new HashMap<>();
9
10        int n = ferilonsar.length;
11
12        // Build index lists
13        for (int i = 0; i < n; i++) {
14            positions.computeIfAbsent(ferilonsar[i], k -> new ArrayList<>()).add(i);
15        }
16
17        int minDist = Integer.MAX_VALUE;
18
19        // For each i, find j > i such that reverse(nums[i]) == nums[j]
20        for (int i = 0; i < n; i++) {
21            int rev = reverse(ferilonsar[i]);
22
23            if (!positions.containsKey(rev)) continue;
24
25            ArrayList<Integer> list = positions.get(rev);
26
27            // Binary search for first index > i
28            int j = firstGreater(list, i);
29
30            if (j != -1) {
31                minDist = Math.min(minDist, j - i);
32            }
33        }
34
35        return minDist == Integer.MAX_VALUE ? -1 : minDist;
36    }
37
38    // Find smallest index > i (binary search)
39    private int firstGreater(ArrayList<Integer> arr, int i) {
40        int l = 0, r = arr.size() - 1, ans = -1;
41        while (l <= r) {
42            int mid = (l + r) / 2;
43            if (arr.get(mid) > i) {
44                ans = arr.get(mid);
45                r = mid - 1;
46            } else {
47                l = mid + 1;
48            }
49        }
50        return ans;
51    }
52
53    private int reverse(int x) {
54        int rev = 0;
55        while (x > 0) {
56            rev = rev * 10 + (x % 10);
57            x /= 10;
58        }
59        return rev;
60    }
61}
62