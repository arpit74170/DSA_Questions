1// Tabulation
2public class MinimumfallingPath2 {
3
4    public static void main(String[] args) {
5        int nums[][] = {{2, 1, 3}, {6, 5, 4}, {7, 8, 9}};
6        ;
7    }
8}
9class Solution {
10     public int minFallingPathSum(int[][] nums) {
11        int m = nums.length;
12        int n = nums[0].length;
13        int grid[][] = new int[m][n];
14        int upleft = Integer.MAX_VALUE;
15        int upright = Integer.MAX_VALUE;
16        int up = Integer.MAX_VALUE;
17        for (int i = 0; i < n; i++) {
18            grid[0][i] = nums[0][i];
19        }
20        for (int i = 1; i < m; i++) {
21            for (int j = 0; j < n; j++) {
22
23                if (j > 0) {
24                    upleft = grid[i - 1][j - 1] + nums[i][j];
25                } else {
26                    upleft = Integer.MAX_VALUE;
27                }
28
29                if (j < n - 1) {
30                    upright = grid[i - 1][j + 1] + nums[i][j];
31                } else {
32                    upright = Integer.MAX_VALUE;
33                }
34
35                up = nums[i][j] + grid[i - 1][j];
36
37                grid[i][j] = Math.min(Math.min(up, upleft), upright);
38            }
39        }
40        int ans = Integer.MAX_VALUE;
41        for (int i = 0; i < n; i++) {
42            ans = Math.min(grid[m - 1][i], ans);
43        }
44        return ans;
45
46
47     }
48}
49
50
51// class Solution {
52//       public static int solve(int nums[][], int i, int j,int dp[][]) {
53//         int m = nums.length;
54//         int n = nums[0].length;
55//          if (i > m - 1 || j > n - 1 || j < 0) {
56//             return Integer.MAX_VALUE;
57//         }
58//         if (i == m - 1) {
59//             return dp[i][j]=nums[i][j];
60//         }
61       
62//         if(dp[i][j]!=-1){
63//             return dp[i][j];
64//         }
65//         int down = solve(nums, i + 1, j,dp);
66//         int leftdown = solve(nums, i + 1, j - 1,dp);
67//         int rightdown = solve(nums, i + 1, j + 1,dp);
68//         dp[i][j]=nums[i][j] + Math.min(Math.min(down, leftdown), rightdown);
69//         return dp[i][j];
70
71
72//     }
73
74//     public int minFallingPathSum(int[][] nums) {
75//          int m = nums.length;
76//         int n = nums[0].length;
77//         int ans = Integer.MAX_VALUE;
78//         int dp[][]=new int[m][n];
79//         for(int i=0;i<m;i++){
80//             for(int j=0;j<n;j++){
81//                 dp[i][j]=-1;
82//             }
83//         }
84//         for (int j = 0; j < n; j++) {
85//             ans = Math.min(ans, solve(nums, 0, j,dp));
86//         }
87
88//         return ans;
89//     }
90// }
91
92
93